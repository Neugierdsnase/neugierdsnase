---
title: Bourgeois web development
subtitle: 'or: how to exploit web workers for cheap labor'
alternativeTitle: an actionable look at web workers
alternativeSubtitle: how to offload non-essential computations from the critical rendering path
author: Konstantin <mail@vomkonstant.in>
published: '2022-05-19'
illustration: 'TODO'
---

There is a long-standing conviction in web development, that is steadily losing its ground: _Single-threadedness._ While JavaScript is a single-threaded language, the browser has evolved to be a platform that can easily and efficiently handle parallel processes. The secret sauce behind this is so-called web workers. This blog post is dedicated to my personal research on this topic.

## What's the critical rendering path (CRP)?

The <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">MDN web docs</a> state:

> The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen.

This is the abovementioned _single-threadedness_ in action. This is a concern, because as web applications grow in complexity, so do the computations they rely on. Clogging the CRP with these tasks, therefore, means delaying the rendering of the user interface to the screen by however much time these computations need.

For most classic websites, this is completely fine, but as web technologies populate more and more different environments with higher and higher performance/optimization needs (i.e. progressive web apps, IoT), this is unacceptable.

## Straightforward API

There is of course a lot of technical debt one could go into, but it is not necessary to leverage the benefits of web workers in your code. In fact, it's probably a lot simpler to delegate work to workers than you might think.

```
             +---------+
             |         |
             |   CRP   |
             |         |
             +--+------+
                |   ^
  postMessage() |   | postMessage()
                v   |
             +------+--+
             |         |
             | Worker  |
             |         |
             +---------+
```

This diagram pretty much encapsulates everything you need to know about how to interact with a web worker. After instantiating a `new Worker('filename.js')` you can use the resulting object to `postMessage()` to it, passing data as arguments. Inside the `filename.js` file we listen to the `onmessage` event, we proceed to do whatever we want with data passed in and can return data back to the main thread again by using `postMessage()` and in return listening to the `onmessage` event on the worker object itself.

Alright, this was a lot of information crammed into a single paragraph, but this has a reason: You're probably not going to handle these things manually anyways (although it's a fun exercise to try). Rather, you will rely on libraries, that are utilizing web workers under the hood.
