import{S as Fe,i as Ke,s as Ne,D as ke,x as Ue,y as Ye,z as Qe,A as Ge,B as ze,r as Ve,p as Xe,C as Ze,P as Be,e as r,t as a,k as w,c as l,a as h,h as s,d as t,m as b,b as ye,g as c,F as o,n as et}from"../../chunks/index-a4305d86.js";import{B as tt}from"../../chunks/BlogPostLayout-2987b3f1.js";import"../../chunks/Article-1fb784f3.js";import"../../chunks/PageHeading-8fc8889e.js";import"../../chunks/index-e10c4c74.js";function ot(C){let n,g,m,k,d,u,v,G,z,_,V,E,X,Z,B,P,O,ee,H,y,te,R,oe,ae,L,x,se,J,S,ie,F,M,ne,K,T,Le=`<code class="language-undefined">             +---------+
             |         |
             |   CRP   |
             |         |
             +--+------+
                |   ^
  postMessage() |   | postMessage()
                v   |
             +------+--+
             |         |
             | Worker  |
             |         |
             +---------+</code>`,N,p,re,j,le,he,$,ce,de,A,pe,fe,I,ue,me,W,ge,we,q,be,ve,U,D,_e;return{c(){n=r("p"),g=a("There is a long-standing conviction in web development, that is steadily losing its ground: "),m=r("em"),k=a("Single-threadedness."),d=a(" While JavaScript is a single-threaded language, the browser has evolved to be a platform that can easily and efficiently handle parallel processes. The secret sauce behind this is so-called web workers. This blog post is dedicated to my personal research on this topic."),u=w(),v=r("h2"),G=a("What\u2019s the critical rendering path (CRP)?"),z=w(),_=r("p"),V=a("The "),E=r("a"),X=a("MDN web docs"),Z=a(" state:"),B=w(),P=r("blockquote"),O=r("p"),ee=a("The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen."),H=w(),y=r("p"),te=a("This is the abovementioned "),R=r("em"),oe=a("single-threadedness"),ae=a(" in action. This is a concern, because as web applications grow in complexity, so do the computations they rely on. Clogging the CRP with these tasks, therefore, means delaying the rendering of the user interface to the screen by however much time these computations need."),L=w(),x=r("p"),se=a("For most classic websites, this is completely fine, but as web technologies populate more and more different environments with higher and higher performance/optimization needs (i.e. progressive web apps, IoT), this is unacceptable."),J=w(),S=r("h2"),ie=a("Straightforward API"),F=w(),M=r("p"),ne=a("There is of course a lot of technical debt one could go into, but it is not necessary to leverage the benefits of web workers in your code. In fact, it\u2019s probably a lot simpler to delegate work to workers than you might think."),K=w(),T=r("pre"),N=w(),p=r("p"),re=a("This diagram pretty much encapsulates everything you need to know about how to interact with a web worker. After instantiating a "),j=r("code"),le=a("new Worker('filename.js')"),he=a(" you can use the resulting object to "),$=r("code"),ce=a("postMessage()"),de=a(" to it, passing data as arguments. Inside the "),A=r("code"),pe=a("filename.js"),fe=a(" file we listen to the "),I=r("code"),ue=a("onmessage"),me=a(" event, we proceed to do whatever we want with data passed in and can return data back to the main thread again by using "),W=r("code"),ge=a("postMessage()"),we=a(" and in return listening to the "),q=r("code"),be=a("onmessage"),ve=a(" event on the worker object itself."),U=w(),D=r("p"),_e=a("Alright, this was a lot of information crammed into a single paragraph, but this has a reason: You\u2019re probably not going to handle these things manually anyways (although it\u2019s a fun exercise to try). Rather, you will rely on libraries, that are utilizing web workers under the hood."),this.h()},l(e){n=l(e,"P",{});var i=h(n);g=s(i,"There is a long-standing conviction in web development, that is steadily losing its ground: "),m=l(i,"EM",{});var Ee=h(m);k=s(Ee,"Single-threadedness."),Ee.forEach(t),d=s(i," While JavaScript is a single-threaded language, the browser has evolved to be a platform that can easily and efficiently handle parallel processes. The secret sauce behind this is so-called web workers. This blog post is dedicated to my personal research on this topic."),i.forEach(t),u=b(e),v=l(e,"H2",{});var Te=h(v);G=s(Te,"What\u2019s the critical rendering path (CRP)?"),Te.forEach(t),z=b(e),_=l(e,"P",{});var Y=h(_);V=s(Y,"The "),E=l(Y,"A",{target:!0,href:!0});var Ce=h(E);X=s(Ce,"MDN web docs"),Ce.forEach(t),Z=s(Y," state:"),Y.forEach(t),B=b(e),P=l(e,"BLOCKQUOTE",{});var Pe=h(P);O=l(Pe,"P",{});var xe=h(O);ee=s(xe,"The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen."),xe.forEach(t),Pe.forEach(t),H=b(e),y=l(e,"P",{});var Q=h(y);te=s(Q,"This is the abovementioned "),R=l(Q,"EM",{});var Se=h(R);oe=s(Se,"single-threadedness"),Se.forEach(t),ae=s(Q," in action. This is a concern, because as web applications grow in complexity, so do the computations they rely on. Clogging the CRP with these tasks, therefore, means delaying the rendering of the user interface to the screen by however much time these computations need."),Q.forEach(t),L=b(e),x=l(e,"P",{});var Me=h(x);se=s(Me,"For most classic websites, this is completely fine, but as web technologies populate more and more different environments with higher and higher performance/optimization needs (i.e. progressive web apps, IoT), this is unacceptable."),Me.forEach(t),J=b(e),S=l(e,"H2",{});var De=h(S);ie=s(De,"Straightforward API"),De.forEach(t),F=b(e),M=l(e,"P",{});var Oe=h(M);ne=s(Oe,"There is of course a lot of technical debt one could go into, but it is not necessary to leverage the benefits of web workers in your code. In fact, it\u2019s probably a lot simpler to delegate work to workers than you might think."),Oe.forEach(t),K=b(e),T=l(e,"PRE",{class:!0});var Je=h(T);Je.forEach(t),N=b(e),p=l(e,"P",{});var f=h(p);re=s(f,"This diagram pretty much encapsulates everything you need to know about how to interact with a web worker. After instantiating a "),j=l(f,"CODE",{});var Re=h(j);le=s(Re,"new Worker('filename.js')"),Re.forEach(t),he=s(f," you can use the resulting object to "),$=l(f,"CODE",{});var je=h($);ce=s(je,"postMessage()"),je.forEach(t),de=s(f," to it, passing data as arguments. Inside the "),A=l(f,"CODE",{});var $e=h(A);pe=s($e,"filename.js"),$e.forEach(t),fe=s(f," file we listen to the "),I=l(f,"CODE",{});var Ae=h(I);ue=s(Ae,"onmessage"),Ae.forEach(t),me=s(f," event, we proceed to do whatever we want with data passed in and can return data back to the main thread again by using "),W=l(f,"CODE",{});var Ie=h(W);ge=s(Ie,"postMessage()"),Ie.forEach(t),we=s(f," and in return listening to the "),q=l(f,"CODE",{});var We=h(q);be=s(We,"onmessage"),We.forEach(t),ve=s(f," event on the worker object itself."),f.forEach(t),U=b(e),D=l(e,"P",{});var qe=h(D);_e=s(qe,"Alright, this was a lot of information crammed into a single paragraph, but this has a reason: You\u2019re probably not going to handle these things manually anyways (although it\u2019s a fun exercise to try). Rather, you will rely on libraries, that are utilizing web workers under the hood."),qe.forEach(t),this.h()},h(){ye(E,"target","_blank"),ye(E,"href","https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path"),ye(T,"class","language-undefined")},m(e,i){c(e,n,i),o(n,g),o(n,m),o(m,k),o(n,d),c(e,u,i),c(e,v,i),o(v,G),c(e,z,i),c(e,_,i),o(_,V),o(_,E),o(E,X),o(_,Z),c(e,B,i),c(e,P,i),o(P,O),o(O,ee),c(e,H,i),c(e,y,i),o(y,te),o(y,R),o(R,oe),o(y,ae),c(e,L,i),c(e,x,i),o(x,se),c(e,J,i),c(e,S,i),o(S,ie),c(e,F,i),c(e,M,i),o(M,ne),c(e,K,i),c(e,T,i),T.innerHTML=Le,c(e,N,i),c(e,p,i),o(p,re),o(p,j),o(j,le),o(p,he),o(p,$),o($,ce),o(p,de),o(p,A),o(A,pe),o(p,fe),o(p,I),o(I,ue),o(p,me),o(p,W),o(W,ge),o(p,we),o(p,q),o(q,be),o(p,ve),c(e,U,i),c(e,D,i),o(D,_e)},p:et,d(e){e&&t(n),e&&t(u),e&&t(v),e&&t(z),e&&t(_),e&&t(B),e&&t(P),e&&t(H),e&&t(y),e&&t(L),e&&t(x),e&&t(J),e&&t(S),e&&t(F),e&&t(M),e&&t(K),e&&t(T),e&&t(N),e&&t(p),e&&t(U),e&&t(D)}}}function at(C){let n,g;const m=[C[0],He];let k={$$slots:{default:[ot]},$$scope:{ctx:C}};for(let d=0;d<m.length;d+=1)k=ke(k,m[d]);return n=new tt({props:k}),{c(){Ue(n.$$.fragment)},l(d){Ye(n.$$.fragment,d)},m(d,u){Qe(n,d,u),g=!0},p(d,[u]){const v=u&1?Ge(m,[u&1&&ze(d[0]),u&0&&ze(He)]):{};u&2&&(v.$$scope={dirty:u,ctx:d}),n.$set(v)},i(d){g||(Ve(n.$$.fragment,d),g=!0)},o(d){Xe(n.$$.fragment,d),g=!1},d(d){Ze(n,d)}}}const He={title:"Bourgeois web development",subtitle:"or: how to exploit web workers for cheap labor",alternativeTitle:"an actionable look at web workers",alternativeSubtitle:"how to offload non-essential computations from the critical rendering path",author:"Konstantin <mail@vomkonstant.in>",published:"2022-05-19",illustration:"TODO"};function st(C,n,g){return C.$$set=m=>{g(0,n=ke(ke({},n),Be(m)))},n=Be(n),[n]}class ct extends Fe{constructor(n){super(),Ke(this,n,st,at,Ne,{})}}export{ct as default,He as metadata};
